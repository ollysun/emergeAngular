{"version":3,"file":"angular2-tag-input.bundle.js","sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 02671c78194fa43719d4","webpack:///external \"@angular/core\"","webpack:///external \"@angular/forms\"","webpack:///./~/rxjs/src/Observable.ts","webpack:///external \"@angular/common\"","webpack:///./~/rxjs/src/Subscriber.ts","webpack:///./~/rxjs/src/util/errorObject.ts","webpack:///./~/rxjs/src/util/isFunction.ts","webpack:///./~/rxjs/src/util/root.ts","webpack:///lib/shared/tag-input-keys.ts","webpack:///./~/rxjs/src/Subscription.ts","webpack:///./~/rxjs/src/symbol/rxSubscriber.ts","webpack:///./~/rxjs/src/util/tryCatch.ts","webpack:///lib/tag-input-autocomplete/tag-input-autocomplete.component.ts","webpack:///lib/tag-input-item/tag-input-item.component.ts","webpack:///lib/tag-input/tag-input.component.ts","webpack:///./lib/tag-input-autocomplete/tag-input-autocomplete.component.html","webpack:///./lib/tag-input-item/tag-input-item.component.html","webpack:///./lib/tag-input/tag-input.component.html","webpack:///./lib/tag-input-autocomplete/tag-input-autocomplete.component.scss","webpack:///./lib/tag-input-item/tag-input-item.component.scss","webpack:///./lib/tag-input/tag-input.component.scss","webpack:///./~/rxjs/src/Observer.ts","webpack:///./~/rxjs/src/add/observable/fromEvent.ts","webpack:///./~/rxjs/src/add/operator/do.ts","webpack:///./~/rxjs/src/add/operator/filter.ts","webpack:///./~/rxjs/src/observable/FromEventObservable.ts","webpack:///./~/rxjs/src/observable/fromEvent.ts","webpack:///./~/rxjs/src/operator/do.ts","webpack:///./~/rxjs/src/operator/filter.ts","webpack:///./~/rxjs/src/symbol/observable.ts","webpack:///./~/rxjs/src/util/UnsubscriptionError.ts","webpack:///./~/rxjs/src/util/isArray.ts","webpack:///./~/rxjs/src/util/isObject.ts","webpack:///./~/rxjs/src/util/toSubscriber.ts","webpack:///(webpack)/buildin/global.js","webpack:///lib/tag-input.module.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@angular/common\"), require(\"@angular/core\"), require(\"@angular/forms\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"@angular/common\", \"@angular/core\", \"@angular/forms\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"angular2-tag-input\"] = factory(require(\"@angular/common\"), require(\"@angular/core\"), require(\"@angular/forms\"));\n\telse\n\t\troot[\"angular2-tag-input\"] = factory(root[\"@angular/common\"], root[\"@angular/core\"], root[\"@angular/forms\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmory imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmory exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tObject.defineProperty(exports, name, {\n \t\t\tconfigurable: false,\n \t\t\tenumerable: true,\n \t\t\tget: getter\n \t\t});\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 35);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 02671c78194fa43719d4","module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"@angular/core\"\n// module id = 0\n// module chunks = 0 1","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"@angular/forms\"\n// module id = 1\n// module chunks = 0 1","import { PartialObserver } from './Observer';\nimport { Operator } from './Operator';\nimport { Subscriber } from './Subscriber';\nimport { Subscription, AnonymousSubscription, TeardownLogic } from './Subscription';\nimport { root } from './util/root';\nimport { toSubscriber } from './util/toSubscriber';\nimport { IfObservable } from './observable/IfObservable';\nimport { ErrorObservable } from './observable/ErrorObservable';\nimport { $$observable } from './symbol/observable';\n\nexport interface Subscribable<T> {\n  subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void),\n            error?: (error: any) => void,\n            complete?: () => void): AnonymousSubscription;\n}\n\nexport type SubscribableOrPromise<T> = Subscribable<T> | Promise<T>;\nexport type ObservableInput<T> = SubscribableOrPromise<T> | ArrayLike<T>;\n\n/**\n * A representation of any set of values over any amount of time. This the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable<T> implements Subscribable<T> {\n\n  public _isScalar: boolean = false;\n\n  protected source: Observable<any>;\n  protected operator: Operator<any, T>;\n\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is  called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: <R>(subscriber: Subscriber<R>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new cold Observable by calling the Observable constructor\n   * @static true\n   * @owner Observable\n   * @method create\n   * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n   * @return {Observable} a new cold observable\n   */\n  static create: Function = <T>(subscribe?: <R>(subscriber: Subscriber<R>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  };\n\n  /**\n   * Creates a new Observable, with this Observable as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param {Operator} operator the operator defining the operation to take on the observable\n   * @return {Observable} a new observable with the Operator applied\n   */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  /**\n   * Registers handlers for handling emitted values, error and completions from the observable, and\n   *  executes the observable's subscriber function, which will take action to set up the underlying data stream\n   * @method subscribe\n   * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,\n   *  or the first of three possible handlers, which is the handler for each value emitted from the observable.\n   * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,\n   *  the error will be thrown as unhandled\n   * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.\n   * @return {ISubscription} a subscription reference to the registered handlers\n   */\n  subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void),\n            error?: (error: any) => void,\n            complete?: () => void): Subscription {\n\n    const { operator } = this;\n    const sink = toSubscriber(observerOrNext, error, complete);\n\n    if (operator) {\n      operator.call(sink, this);\n    } else {\n      sink.add(this._subscribe(sink));\n    }\n\n    if (sink.syncErrorThrowable) {\n      sink.syncErrorThrowable = false;\n      if (sink.syncErrorThrown) {\n        throw sink.syncErrorValue;\n      }\n    }\n\n    return sink;\n  }\n\n  /**\n   * @method forEach\n   * @param {Function} next a handler for each value emitted by the observable\n   * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n   * @return {Promise} a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n  forEach(next: (value: T) => void, PromiseCtor?: typeof Promise): Promise<void> {\n    if (!PromiseCtor) {\n      if (root.Rx && root.Rx.config && root.Rx.config.Promise) {\n        PromiseCtor = root.Rx.config.Promise;\n      } else if (root.Promise) {\n        PromiseCtor = root.Promise;\n      }\n    }\n\n    if (!PromiseCtor) {\n      throw new Error('no Promise impl found');\n    }\n\n    return new PromiseCtor<void>((resolve, reject) => {\n      const subscription = this.subscribe((value) => {\n        if (subscription) {\n          // if there is a subscription, then we can surmise\n          // the next handling is asynchronous. Any errors thrown\n          // need to be rejected explicitly and unsubscribe must be\n          // called manually\n          try {\n            next(value);\n          } catch (err) {\n            reject(err);\n            subscription.unsubscribe();\n          }\n        } else {\n          // if there is NO subscription, then we're getting a nexted\n          // value synchronously during subscription. We can just call it.\n          // If it errors, Observable's `subscribe` will ensure the\n          // unsubscription logic is called, then synchronously rethrow the error.\n          // After that, Promise will trap the error and send it\n          // down the rejection path.\n          next(value);\n        }\n      }, reject, resolve);\n    });\n  }\n\n  protected _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    return this.source.subscribe(subscriber);\n  }\n\n  // `if` and `throw` are special snow flakes, the compiler sees them as reserved words\n  static if: typeof IfObservable.create;\n  static throw: typeof ErrorObservable.create;\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n  [$$observable]() {\n    return this;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/rxjs/src/Observable.ts","module.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"@angular/common\"\n// module id = 3\n// module chunks = 0 1","import { isFunction } from './util/isFunction';\nimport { Observer, PartialObserver } from './Observer';\nimport { Subscription } from './Subscription';\nimport { empty as emptyObserver } from './Observer';\nimport { $$rxSubscriber } from './symbol/rxSubscriber';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n\n  [$$rxSubscriber]() { return this; }\n\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   */\n  static create<T>(next?: (x?: T) => void,\n                   error?: (e?: any) => void,\n                   complete?: () => void): Subscriber<T> {\n    const subscriber = new Subscriber(next, error, complete);\n    subscriber.syncErrorThrowable = false;\n    return subscriber;\n  }\n\n  public syncErrorValue: any = null;\n  public syncErrorThrown: boolean = false;\n  public syncErrorThrowable: boolean = false;\n\n  protected isStopped: boolean = false;\n  protected destination: PartialObserver<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n   * defined Observer or a `next` callback function.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   */\n  constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    switch (arguments.length) {\n      case 0:\n        this.destination = emptyObserver;\n        break;\n      case 1:\n        if (!destinationOrNext) {\n          this.destination = emptyObserver;\n          break;\n        }\n        if (typeof destinationOrNext === 'object') {\n          if (destinationOrNext instanceof Subscriber) {\n            this.destination = (<Subscriber<any>> destinationOrNext);\n            (<any> this.destination).add(this);\n          } else {\n            this.syncErrorThrowable = true;\n            this.destination = new SafeSubscriber<T>(this, <PartialObserver<any>> destinationOrNext);\n          }\n          break;\n        }\n      default:\n        this.syncErrorThrowable = true;\n        this.destination = new SafeSubscriber<T>(this, <((value: T) => void)> destinationOrNext, error, complete);\n        break;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (!this.isStopped) {\n      this._next(value);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached {@link Error}. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (this.closed) {\n      return;\n    }\n    this.isStopped = true;\n    super.unsubscribe();\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    this.destination.error(err);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.destination.complete();\n    this.unsubscribe();\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SafeSubscriber<T> extends Subscriber<T> {\n\n  private _context: any;\n\n  constructor(private _parent: Subscriber<T>,\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    let next: ((value: T) => void);\n    let context: any = this;\n\n    if (isFunction(observerOrNext)) {\n      next = (<((value: T) => void)> observerOrNext);\n    } else if (observerOrNext) {\n      context = observerOrNext;\n      next = (<PartialObserver<T>> observerOrNext).next;\n      error = (<PartialObserver<T>> observerOrNext).error;\n      complete = (<PartialObserver<T>> observerOrNext).complete;\n      if (isFunction(context.unsubscribe)) {\n        this.add(<() => void> context.unsubscribe.bind(context));\n      }\n      context.unsubscribe = this.unsubscribe.bind(this);\n    }\n\n    this._context = context;\n    this._next = next;\n    this._error = error;\n    this._complete = complete;\n  }\n\n  next(value?: T): void {\n    if (!this.isStopped && this._next) {\n      const { _parent } = this;\n      if (!_parent.syncErrorThrowable) {\n        this.__tryOrUnsub(this._next, value);\n      } else if (this.__tryOrSetError(_parent, this._next, value)) {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  error(err?: any): void {\n    if (!this.isStopped) {\n      const { _parent } = this;\n      if (this._error) {\n        if (!_parent.syncErrorThrowable) {\n          this.__tryOrUnsub(this._error, err);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parent, this._error, err);\n          this.unsubscribe();\n        }\n      } else if (!_parent.syncErrorThrowable) {\n        this.unsubscribe();\n        throw err;\n      } else {\n        _parent.syncErrorValue = err;\n        _parent.syncErrorThrown = true;\n        this.unsubscribe();\n      }\n    }\n  }\n\n  complete(): void {\n    if (!this.isStopped) {\n      const { _parent } = this;\n      if (this._complete) {\n        if (!_parent.syncErrorThrowable) {\n          this.__tryOrUnsub(this._complete);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parent, this._complete);\n          this.unsubscribe();\n        }\n      } else {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  private __tryOrUnsub(fn: Function, value?: any): void {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      this.unsubscribe();\n      throw err;\n    }\n  }\n\n  private __tryOrSetError(parent: Subscriber<T>, fn: Function, value?: any): boolean {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      parent.syncErrorValue = err;\n      parent.syncErrorThrown = true;\n      return true;\n    }\n    return false;\n  }\n\n  protected _unsubscribe(): void {\n    const { _parent } = this;\n    this._context = null;\n    this._parent = null;\n    _parent.unsubscribe();\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/rxjs/src/Subscriber.ts","// typeof any so that it we don't have to cast when comparing a result to the error object\nexport var errorObject: any = { e: {} };\n\n\n// WEBPACK FOOTER //\n// ./~/rxjs/src/util/errorObject.ts","export function isFunction(x: any): x is Function {\n  return typeof x === 'function';\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/rxjs/src/util/isFunction.ts","let objectTypes = {\n  'boolean': false,\n  'function': true,\n  'object': true,\n  'number': false,\n  'string': false,\n  'undefined': false\n};\n\ndeclare let global: NodeJS.Global;\ndeclare let module: any;\ndeclare let exports: any;\n\ndeclare module NodeJS {\n  interface Global {\n    window: any;\n    global: any;\n  }\n}\n\nexport let root: any = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);\n\nlet freeGlobal = objectTypes[typeof global] && global;\nif (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n  root = freeGlobal;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/rxjs/src/util/root.ts","export const KEYS = {\r\n  backspace: 8,\r\n  comma: 188,\r\n  downArrow: 40,\r\n  enter: 13,\r\n  esc: 27,\r\n  space: 32,\r\n  upArrow: 38\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// lib/shared/tag-input-keys.ts","import { isArray } from './util/isArray';\nimport { isObject } from './util/isObject';\nimport { isFunction } from './util/isFunction';\nimport { tryCatch } from './util/tryCatch';\nimport { errorObject } from './util/errorObject';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\n\nexport interface AnonymousSubscription {\n  unsubscribe(): void;\n}\n\nexport type TeardownLogic = AnonymousSubscription | Function | void;\n\nexport interface ISubscription extends AnonymousSubscription {\n  unsubscribe(): void;\n  closed: boolean;\n}\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription implements ISubscription {\n  public static EMPTY: Subscription = (function(empty: any){\n    empty.closed = true;\n    return empty;\n  }(new Subscription()));\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   * @type {boolean}\n   */\n  public closed: boolean = false;\n\n  /**\n   * @param {function(): void} [unsubscribe] A function describing how to\n   * perform the disposal of resources when the `unsubscribe` method is called.\n   */\n  constructor(unsubscribe?: () => void) {\n    if (unsubscribe) {\n      (<any> this)._unsubscribe = unsubscribe;\n    }\n  }\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  unsubscribe(): void {\n    let hasErrors = false;\n    let errors: any[];\n\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n\n    const { _unsubscribe, _subscriptions } = (<any> this);\n\n    (<any> this)._subscriptions = null;\n\n    if (isFunction(_unsubscribe)) {\n      let trial = tryCatch(_unsubscribe).call(this);\n      if (trial === errorObject) {\n        hasErrors = true;\n        (errors = errors || []).push(errorObject.e);\n      }\n    }\n\n    if (isArray(_subscriptions)) {\n\n      let index = -1;\n      const len = _subscriptions.length;\n\n      while (++index < len) {\n        const sub = _subscriptions[index];\n        if (isObject(sub)) {\n          let trial = tryCatch(sub.unsubscribe).call(sub);\n          if (trial === errorObject) {\n            hasErrors = true;\n            errors = errors || [];\n            let err = errorObject.e;\n            if (err instanceof UnsubscriptionError) {\n              errors = errors.concat(err.errors);\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n    }\n\n    if (hasErrors) {\n      throw new UnsubscriptionError(errors);\n    }\n  }\n\n  /**\n   * Adds a tear down to be called during the unsubscribe() of this\n   * Subscription.\n   *\n   * If the tear down being added is a subscription that is already\n   * unsubscribed, is the same reference `add` is being called on, or is\n   * `Subscription.EMPTY`, it will not be added.\n   *\n   * If this subscription is already in an `closed` state, the passed\n   * tear down logic will be executed immediately.\n   *\n   * @param {TeardownLogic} teardown The additional logic to execute on\n   * teardown.\n   * @return {Subscription} Returns the Subscription used or created to be\n   * added to the inner subscriptions list. This Subscription can be used with\n   * `remove()` to remove the passed teardown logic from the inner subscriptions\n   * list.\n   */\n  add(teardown: TeardownLogic): Subscription {\n    if (!teardown || (teardown === Subscription.EMPTY)) {\n      return Subscription.EMPTY;\n    }\n\n    if (teardown === this) {\n      return this;\n    }\n\n    let sub = (<Subscription> teardown);\n\n    switch (typeof teardown) {\n      case 'function':\n        sub = new Subscription(<(() => void) > teardown);\n      case 'object':\n        if (sub.closed || typeof sub.unsubscribe !== 'function') {\n          break;\n        } else if (this.closed) {\n          sub.unsubscribe();\n        } else {\n          ((<any> this)._subscriptions || ((<any> this)._subscriptions = [])).push(sub);\n        }\n        break;\n      default:\n        throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n    }\n\n    return sub;\n  }\n\n  /**\n   * Removes a Subscription from the internal list of subscriptions that will\n   * unsubscribe during the unsubscribe process of this Subscription.\n   * @param {Subscription} subscription The subscription to remove.\n   * @return {void}\n   */\n  remove(subscription: Subscription): void {\n\n    // HACK: This might be redundant because of the logic in `add()`\n    if (subscription == null   || (\n        subscription === this) || (\n        subscription === Subscription.EMPTY)) {\n      return;\n    }\n\n    const subscriptions = (<any> this)._subscriptions;\n\n    if (subscriptions) {\n      const subscriptionIndex = subscriptions.indexOf(subscription);\n      if (subscriptionIndex !== -1) {\n        subscriptions.splice(subscriptionIndex, 1);\n      }\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/rxjs/src/Subscription.ts","import { root } from '../util/root';\n\nconst Symbol: any = root.Symbol;\n\nexport const $$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n  Symbol.for('rxSubscriber') : '@@rxSubscriber';\n\n\n\n// WEBPACK FOOTER //\n// ./~/rxjs/src/symbol/rxSubscriber.ts","import { errorObject } from './errorObject';\n\nlet tryCatchTarget: Function;\n\nfunction tryCatcher(): any {\n  try {\n    return tryCatchTarget.apply(this, arguments);\n  } catch (e) {\n    errorObject.e = e;\n    return errorObject;\n  }\n}\n\nexport function tryCatch<T extends Function>(fn: T): T {\n  tryCatchTarget = fn;\n  return <any>tryCatcher;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./~/rxjs/src/util/tryCatch.ts","import { Component, ElementRef, EventEmitter, Input, OnChanges, OnDestroy, OnInit, Output } from '@angular/core';\r\nimport { Observable } from 'rxjs/Observable';\r\nimport { Subscription } from 'rxjs/Subscription';\r\nimport 'rxjs/add/observable/fromEvent';\r\nimport 'rxjs/add/operator/filter';\r\nimport 'rxjs/add/operator/do';\r\n\r\nimport { KEYS } from '../shared/tag-input-keys';\r\n\r\n@Component({\r\n  selector: 'rl-tag-input-autocomplete',\r\n  template: require('./tag-input-autocomplete.component.html'),\r\n  styles: [require('./tag-input-autocomplete.component.scss').toString()]\r\n})\r\nexport class TagInputAutocompleteComponent implements OnChanges, OnDestroy, OnInit {\r\n  @Input() items: string[];\r\n  @Input() selectFirstItem: boolean = false;\r\n  @Output() itemSelected: EventEmitter<string> = new EventEmitter<string>();\r\n  @Output() enterPressed: EventEmitter<any> = new EventEmitter<any>();\r\n  public selectedItemIndex: number = null;\r\n  private keySubscription: Subscription;\r\n  private get itemsCount(): Number {\r\n    return this.items ? this.items.length : 0;\r\n  }\r\n\r\n  constructor(private elementRef: ElementRef) { }\r\n\r\n  ngOnInit() {\r\n    this.keySubscription = Observable.fromEvent(window, 'keydown')\r\n    .filter(\r\n      (event: KeyboardEvent) =>\r\n      event.keyCode === KEYS.upArrow ||\r\n      event.keyCode === KEYS.downArrow ||\r\n      event.keyCode === KEYS.enter ||\r\n      event.keyCode === KEYS.esc\r\n    )\r\n    .do((event: KeyboardEvent) => {\r\n      switch (event.keyCode) {\r\n        case KEYS.downArrow:\r\n          this.handleDownArrow();\r\n          break;\r\n\r\n        case KEYS.upArrow:\r\n          this.handleUpArrow();\r\n          break;\r\n\r\n        case KEYS.enter:\r\n          this.selectItem();\r\n          this.enterPressed.emit();\r\n          break;\r\n\r\n        case KEYS.esc:\r\n          break;\r\n      }\r\n\r\n      event.stopPropagation();\r\n      event.preventDefault();\r\n    })\r\n    .subscribe();\r\n  }\r\n\r\n  ensureHighlightVisible() {\r\n    let container = this.elementRef.nativeElement.querySelector('.sk-select-results__container');\r\n    if (!container) {\r\n      return;\r\n    }\r\n    let choices = container.querySelectorAll('.sk-select-results__item');\r\n    if (choices.length < 1) {\r\n      return;\r\n    }\r\n    if (this.selectedItemIndex < 0) {\r\n      return;\r\n    }\r\n    let highlighted: any = choices[this.selectedItemIndex];\r\n    if (!highlighted) {\r\n      return;\r\n    }\r\n    let posY: number = highlighted.offsetTop + highlighted.clientHeight - container.scrollTop;\r\n    let height: number = container.offsetHeight;\r\n\r\n    if (posY > height) {\r\n      container.scrollTop += posY - height;\r\n    } else if (posY < highlighted.clientHeight) {\r\n      container.scrollTop -= highlighted.clientHeight - posY;\r\n    }\r\n  }\r\n\r\n  goToTop() {\r\n    this.selectedItemIndex = 0;\r\n    this.ensureHighlightVisible();\r\n  }\r\n\r\n  goToBottom(itemsCount) {\r\n    this.selectedItemIndex = itemsCount - 1;\r\n    this.ensureHighlightVisible();\r\n  }\r\n\r\n  goToNext() {\r\n    if (this.selectedItemIndex + 1 < this.itemsCount) {\r\n      this.selectedItemIndex++;\r\n    } else {\r\n      this.goToTop();\r\n    }\r\n    this.ensureHighlightVisible();\r\n  }\r\n\r\n  goToPrevious() {\r\n    if (this.selectedItemIndex - 1 >= 0) {\r\n      this.selectedItemIndex--;\r\n    } else {\r\n      this.goToBottom(this.itemsCount);\r\n    }\r\n    this.ensureHighlightVisible();\r\n  }\r\n\r\n  handleUpArrow() {\r\n    if (this.selectedItemIndex === null) {\r\n      this.goToBottom(this.itemsCount);\r\n      return false;\r\n    }\r\n    this.goToPrevious();\r\n  }\r\n\r\n  handleDownArrow() {\r\n    // Initialize to zero if first time results are shown\r\n    if (this.selectedItemIndex === null) {\r\n        this.goToTop();\r\n        return false;\r\n    }\r\n    this.goToNext();\r\n  }\r\n\r\n  selectItem(itemIndex?: number): void {\r\n    let itemToEmit = itemIndex ? this.items[itemIndex] : this.items[this.selectedItemIndex];\r\n    if (itemToEmit) {\r\n      this.itemSelected.emit(itemToEmit);\r\n    }\r\n  }\r\n\r\n  ngOnChanges() {\r\n    if (this.selectFirstItem && this.itemsCount > 0) {\r\n      this.goToTop();\r\n    }\r\n  }\r\n\r\n  ngOnDestroy() {\r\n    this.keySubscription.unsubscribe();\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// lib/tag-input-autocomplete/tag-input-autocomplete.component.ts","import { Component, EventEmitter, HostBinding, Input, Output } from '@angular/core';\r\n\r\n@Component({\r\n  selector: 'rl-tag-input-item',\r\n  template: require('./tag-input-item.component.html'),\r\n  styles: [require('./tag-input-item.component.scss').toString()]\r\n})\r\nexport class TagInputItemComponent {\r\n  @Input() selected: boolean;\r\n  @Input() text: string;\r\n  @Input() index: number;\r\n  @Output() tagRemoved: EventEmitter<number> = new EventEmitter<number>();\r\n  @HostBinding('class.ng2-tag-input-item-selected') 'selected === true';\r\n\r\n  constructor() { }\r\n\r\n  removeTag(): void {\r\n    this.tagRemoved.emit(this.index);\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// lib/tag-input-item/tag-input-item.component.ts","import { Component, EventEmitter, HostBinding, Input, forwardRef, OnDestroy, OnInit, Output } from '@angular/core';\r\nimport { AbstractControl, ControlValueAccessor, NG_VALUE_ACCESSOR, FormBuilder, FormGroup } from '@angular/forms';\r\nimport { Subscription } from 'rxjs';\r\n\r\nimport { KEYS } from '../shared/tag-input-keys';\r\n\r\n/**\r\n * Taken from @angular/common/src/facade/lang\r\n */\r\nfunction isBlank(obj: any): boolean {\r\n  return obj === undefined || obj === null;\r\n}\r\n\r\nexport interface AutoCompleteItem {\r\n  [index: string]: any;\r\n}\r\n\r\n@Component({\r\n  selector: 'rl-tag-input',\r\n  template: require('./tag-input.component.html'),\r\n  styles: [require('./tag-input.component.scss').toString()],\r\n  providers: [\r\n    {provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => TagInputComponent), multi: true},\r\n  ]\r\n})\r\nexport class TagInputComponent implements ControlValueAccessor, OnDestroy, OnInit {\r\n  @HostBinding('class.ng2-tag-input-focus') isFocused;\r\n  @Input() addOnBlur: boolean = true;\r\n  @Input() addOnComma: boolean = true;\r\n  @Input() addOnEnter: boolean = true;\r\n  @Input() addOnPaste: boolean = true;\r\n  @Input() addOnSpace: boolean = false;\r\n  @Input() allowDuplicates: boolean = false;\r\n  @Input() allowedTagsPattern: RegExp = /.+/;\r\n  @Input() autocomplete: boolean = false;\r\n  @Input() autocompleteItems: string[] = [];\r\n  @Input() autocompleteMustMatch: boolean = true;\r\n  @Input() autocompleteSelectFirstItem: boolean = true;\r\n  @Input() pasteSplitPattern: string = ',';\r\n  @Input() placeholder: string = 'Add a tag';\r\n  @Output('addTag') addTag: EventEmitter<string> = new EventEmitter<string>();\r\n  @Output('removeTag') removeTag: EventEmitter<string> = new EventEmitter<string>();\r\n\r\n  public tagInputForm: FormGroup;\r\n  public autocompleteResults: string[] = [];\r\n  public tagsList: string[] = [];\r\n  public selectedTag: number;\r\n  private tagInputSubscription: Subscription;\r\n  private splitRegExp: RegExp;\r\n  private get tagInputField(): AbstractControl {\r\n    return this.tagInputForm.get('tagInputField');\r\n  }\r\n  private get inputValue(): string {\r\n    return this.tagInputField.value;\r\n  }\r\n\r\n  constructor(private fb: FormBuilder) {}\r\n\r\n  ngOnInit() {\r\n    this.splitRegExp = new RegExp(this.pasteSplitPattern);\r\n\r\n    this.tagInputForm = this.fb.group({\r\n      tagInputField: ''\r\n    });\r\n\r\n    this.tagInputSubscription = this.tagInputField.valueChanges\r\n    .do(value => {\r\n      this.autocompleteResults = this.autocompleteItems.filter(item => {\r\n        /**\r\n         * _isTagUnique makes sure to remove items from the autocompelte dropdown if they have\r\n         * already been added to the model, and allowDuplicates is false\r\n         */\r\n        return item.toLowerCase().indexOf(value.toLowerCase()) > -1 && this._isTagUnique(item);\r\n      });\r\n    })\r\n    .subscribe();\r\n  }\r\n\r\n  onKeydown(event: KeyboardEvent): void {\r\n    let key = event.keyCode;\r\n    switch (key) {\r\n      case KEYS.backspace:\r\n        this._handleBackspace();\r\n        break;\r\n\r\n      case KEYS.enter:\r\n        if (this.addOnEnter && !this.showAutocomplete()) {\r\n          this._addTags([this.inputValue]);\r\n          event.preventDefault();\r\n        }\r\n        break;\r\n\r\n      case KEYS.comma:\r\n        if (this.addOnComma) {\r\n          this._addTags([this.inputValue]);\r\n          event.preventDefault();\r\n        }\r\n        break;\r\n\r\n      case KEYS.space:\r\n        if (this.addOnSpace) {\r\n          this._addTags([this.inputValue]);\r\n          event.preventDefault();\r\n        }\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  onInputBlurred(event): void {\r\n    if (this.addOnBlur) { this._addTags([this.inputValue]); }\r\n    this.isFocused = false;\r\n  }\r\n\r\n  onInputFocused(event): void {\r\n    this.isFocused = true;\r\n  }\r\n\r\n  onInputPaste(event): void {\r\n    let clipboardData = event.clipboardData || (event.originalEvent && event.originalEvent.clipboardData);\r\n    let pastedString = clipboardData.getData('text/plain');\r\n    let tags = this._splitString(pastedString);\r\n    this._addTags(tags);\r\n    setTimeout(() => this._resetInput());\r\n  }\r\n\r\n  onAutocompleteSelect(selectedItem) {\r\n    this._addTags([selectedItem]);\r\n  }\r\n\r\n  onAutocompleteEnter() {\r\n    if (this.addOnEnter && this.showAutocomplete() && !this.autocompleteMustMatch) {\r\n      this._addTags([this.inputValue]);\r\n    }\r\n  }\r\n\r\n  showAutocomplete(): boolean {\r\n    return (this.autocomplete && this.autocompleteItems.length > 0 && this.inputValue.length > 0);\r\n  }\r\n\r\n  private _splitString(tagString: string): string[] {\r\n    tagString = tagString.trim();\r\n    let tags = tagString.split(this.splitRegExp);\r\n    return tags.filter((tag) => !!tag);\r\n  }\r\n\r\n  private _isTagValid(tagString: string): boolean {\r\n    return this.allowedTagsPattern.test(tagString) && this._isTagUnique(tagString);\r\n  }\r\n\r\n  private _isTagUnique(tagString: string): boolean {\r\n    return this.allowDuplicates ? true : this.tagsList.indexOf(tagString) === -1;\r\n  }\r\n\r\n  private _isTagAutocompleteItem(tagString: string): boolean {\r\n    return this.autocompleteItems.indexOf(tagString) > -1;\r\n  }\r\n\r\n  private _emitTagAdded(addedTags: string[]): void {\r\n    addedTags.forEach(tag => this.addTag.emit(tag));\r\n  }\r\n\r\n  private _emitTagRemoved(removedTag): void {\r\n    this.removeTag.emit(removedTag);\r\n  }\r\n\r\n  private _addTags(tags: string[]): void {\r\n    let validTags = tags.map(tag => tag.trim())\r\n                        .filter(tag => this._isTagValid(tag))\r\n                        .filter(tag => this._isTagUnique(tag))\r\n                        .filter(tag => (this.showAutocomplete() && this.autocompleteMustMatch) ? this._isTagAutocompleteItem(tag) : true);\r\n\r\n    this.tagsList = this.tagsList.concat(validTags);\r\n    this._resetSelected();\r\n    this._resetInput();\r\n    this.onChange(this.tagsList);\r\n    this._emitTagAdded(validTags);\r\n  }\r\n\r\n  private _removeTag(tagIndexToRemove: number): void {\r\n    let removedTag = this.tagsList[tagIndexToRemove];\r\n    this.tagsList.splice(tagIndexToRemove, 1);\r\n    this._resetSelected();\r\n    this.onChange(this.tagsList);\r\n    this._emitTagRemoved(removedTag);\r\n  }\r\n\r\n  private _handleBackspace(): void {\r\n    if (!this.inputValue.length && this.tagsList.length) {\r\n      if (!isBlank(this.selectedTag)) {\r\n        this._removeTag(this.selectedTag);\r\n      } else {\r\n        this.selectedTag = this.tagsList.length - 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  private _resetSelected(): void {\r\n    this.selectedTag = null;\r\n  }\r\n\r\n  private _resetInput(): void {\r\n    this.tagInputField.setValue('');\r\n  }\r\n\r\n  /** Implemented as part of ControlValueAccessor. */\r\n  onChange: (value) => any = () => { };\r\n\r\n  onTouched: () => any = () => { };\r\n\r\n  writeValue(value: any) {\r\n    this.tagsList = value;\r\n  }\r\n\r\n  registerOnChange(fn: any) {\r\n    this.onChange = fn;\r\n  }\r\n\r\n  registerOnTouched(fn: any) {\r\n    this.onTouched = fn;\r\n  }\r\n\r\n  ngOnDestroy() {\r\n    this.tagInputSubscription.unsubscribe();\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// lib/tag-input/tag-input.component.ts","module.exports = \"<div\\r\\n  *ngFor=\\\"let item of items; let itemIndex = index\\\"\\r\\n  [ngClass]=\\\"{ 'is-selected': selectedItemIndex === itemIndex }\\\"\\r\\n  (click)=\\\"selectItem(itemIndex)\\\"\\r\\n  class=\\\"rl-autocomplete-item\\\">\\r\\n  {{item}}\\r\\n</div>\\r\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/tag-input-autocomplete/tag-input-autocomplete.component.html\n// module id = 15\n// module chunks = 0","module.exports = \"{{text}}\\r\\n<span\\r\\nclass=\\\"ng2-tag-input-remove\\\"\\r\\n(click)=\\\"removeTag()\\\">&times;</span>\\r\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/tag-input-item/tag-input-item.component.html\n// module id = 16\n// module chunks = 0","module.exports = \"<rl-tag-input-item\\r\\n  [text]=\\\"tag\\\"\\r\\n  [index]=\\\"index\\\"\\r\\n  [selected]=\\\"selectedTag === index\\\"\\r\\n  (tagRemoved)=\\\"_removeTag($event)\\\"\\r\\n  *ngFor=\\\"let tag of tagsList; let index = index\\\">\\r\\n</rl-tag-input-item>\\r\\n<form [formGroup]=\\\"tagInputForm\\\" class=\\\"ng2-tag-input-form\\\">\\r\\n  <input\\r\\n    class=\\\"ng2-tag-input-field\\\"\\r\\n    type=\\\"text\\\"\\r\\n    formControlName=\\\"tagInputField\\\"\\r\\n    [placeholder]=\\\"placeholder\\\"\\r\\n    (paste)=\\\"onInputPaste($event)\\\"\\r\\n    (keydown)=\\\"onKeydown($event)\\\"\\r\\n    (blur)=\\\"onInputBlurred($event)\\\"\\r\\n    (focus)=\\\"onInputFocused()\\\">\\r\\n\\r\\n  <div *ngIf=\\\"showAutocomplete()\\\" class=\\\"rl-tag-input-autocomplete-container\\\">\\r\\n    <rl-tag-input-autocomplete\\r\\n      [items]=\\\"autocompleteResults\\\"\\r\\n      [selectFirstItem]=\\\"autocompleteSelectFirstItem\\\"\\r\\n      (itemSelected)=\\\"onAutocompleteSelect($event)\\\"\\r\\n      (enterPressed)=\\\"onAutocompleteEnter($event)\\\">\\r\\n    </rl-tag-input-autocomplete>\\r\\n  </div>\\r\\n</form>\\r\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/tag-input/tag-input.component.html\n// module id = 17\n// module chunks = 0","module.exports = \":host {\\n  box-shadow: 0 1.5px 4px rgba(0, 0, 0, 0.24), 0 1.5px 6px rgba(0, 0, 0, 0.12);\\n  display: block;\\n  position: absolute;\\n  top: 100%;\\n  font-family: \\\"Roboto\\\", \\\"Helvetica Neue\\\", sans-serif;\\n  font-size: 16px;\\n  color: #444444;\\n  background: white;\\n  padding: 8px 0; }\\n  :host .rl-autocomplete-item {\\n    padding: 0 16px;\\n    height: 48px;\\n    line-height: 48px; }\\n  :host .is-selected {\\n    background: #eeeeee; }\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/tag-input-autocomplete/tag-input-autocomplete.component.scss\n// module id = 18\n// module chunks = 0","module.exports = \":host {\\n  font-family: \\\"Roboto\\\", \\\"Helvetica Neue\\\", sans-serif;\\n  font-size: 16px;\\n  height: 32px;\\n  line-height: 32px;\\n  display: inline-block;\\n  background: #e0e0e0;\\n  padding: 0 12px;\\n  border-radius: 90px;\\n  margin-right: 10px;\\n  -webkit-transition: all 0.12s ease-out;\\n  transition: all 0.12s ease-out; }\\n  :host .ng2-tag-input-remove {\\n    background: #a6a6a6;\\n    border-radius: 50%;\\n    color: #e0e0e0;\\n    cursor: pointer;\\n    display: inline-block;\\n    font-size: 17px;\\n    height: 24px;\\n    line-height: 24px;\\n    margin-left: 6px;\\n    margin-right: -6px;\\n    text-align: center;\\n    width: 24px; }\\n\\n:host.ng2-tag-input-item-selected {\\n  color: white;\\n  background: #0d8bff; }\\n  :host.ng2-tag-input-item-selected .ng2-tag-input-remove {\\n    background: white;\\n    color: #0d8bff; }\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/tag-input-item/tag-input-item.component.scss\n// module id = 19\n// module chunks = 0","module.exports = \":host {\\n  font-family: \\\"Roboto\\\", \\\"Helvetica Neue\\\", sans-serif;\\n  font-size: 16px;\\n  display: block;\\n  box-shadow: 0 1px #ccc;\\n  padding: 8px 0 6px 0;\\n  will-change: box-shadow;\\n  -webkit-transition: box-shadow 0.12s ease-out;\\n  transition: box-shadow 0.12s ease-out; }\\n  :host .ng2-tag-input-form {\\n    display: inline; }\\n  :host .ng2-tag-input-field {\\n    font-family: \\\"Roboto\\\", \\\"Helvetica Neue\\\", sans-serif;\\n    font-size: 16px;\\n    display: inline-block;\\n    width: auto;\\n    box-shadow: none;\\n    border: 0;\\n    padding: 8px 0; }\\n    :host .ng2-tag-input-field:focus {\\n      outline: 0; }\\n  :host .rl-tag-input-autocomplete-container {\\n    position: relative;\\n    z-index: 10; }\\n\\n:host.ng2-tag-input-focus {\\n  box-shadow: 0 2px #0d8bff; }\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/tag-input/tag-input.component.scss\n// module id = 20\n// module chunks = 0","export interface NextObserver<T> {\n  closed?: boolean;\n  next: (value: T) => void;\n  error?: (err: any) => void;\n  complete?: () => void;\n}\n\nexport interface ErrorObserver<T> {\n  closed?: boolean;\n  next?: (value: T) => void;\n  error: (err: any) => void;\n  complete?: () => void;\n}\n\nexport interface CompletionObserver<T> {\n  closed?: boolean;\n  next?: (value: T) => void;\n  error?: (err: any) => void;\n  complete: () => void;\n}\n\nexport type PartialObserver<T> = NextObserver<T> | ErrorObserver<T> | CompletionObserver<T>;\n\nexport interface Observer<T> {\n  closed?: boolean;\n  next: (value: T) => void;\n  error: (err: any) => void;\n  complete: () => void;\n}\n\nexport const empty: Observer<any> = {\n  closed: true,\n  next(value: any): void { /* noop */},\n  error(err: any): void { throw err; },\n  complete(): void { /*noop*/ }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./~/rxjs/src/Observer.ts","import { Observable } from '../../Observable';\nimport { fromEvent as staticFromEvent } from '../../observable/fromEvent';\n\nObservable.fromEvent = staticFromEvent;\n\ndeclare module '../../Observable' {\n  namespace Observable {\n    export let fromEvent: typeof staticFromEvent;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./~/rxjs/src/add/observable/fromEvent.ts","\nimport { Observable } from '../../Observable';\nimport { _do, DoSignature } from '../../operator/do';\n\nObservable.prototype.do = _do;\nObservable.prototype._do = _do;\n\ndeclare module '../../Observable' {\n  interface Observable<T> {\n    do: DoSignature<T>;\n    _do: DoSignature<T>;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./~/rxjs/src/add/operator/do.ts","\nimport { Observable } from '../../Observable';\nimport { filter, FilterSignature } from '../../operator/filter';\n\nObservable.prototype.filter = filter;\n\ndeclare module '../../Observable' {\n  interface Observable<T> {\n    filter: FilterSignature<T>;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./~/rxjs/src/add/operator/filter.ts","import { Observable } from '../Observable';\nimport { tryCatch } from '../util/tryCatch';\nimport { isFunction } from '../util/isFunction';\nimport { errorObject } from '../util/errorObject';\nimport { Subscription } from '../Subscription';\nimport { Subscriber } from '../Subscriber';\n\nexport type NodeStyleEventEmmitter = {\n  addListener: (eventName: string, handler: Function) => void;\n  removeListener: (eventName: string, handler: Function) => void;\n};\nfunction isNodeStyleEventEmmitter(sourceObj: any): sourceObj is NodeStyleEventEmmitter {\n  return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\n\nexport type JQueryStyleEventEmitter = {\n  on: (eventName: string, handler: Function) => void;\n  off: (eventName: string, handler: Function) => void;\n};\nfunction isJQueryStyleEventEmitter(sourceObj: any): sourceObj is JQueryStyleEventEmitter {\n  return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\n\nfunction isNodeList(sourceObj: any): sourceObj is NodeList {\n  return !!sourceObj && sourceObj.toString() === '[object NodeList]';\n}\n\nfunction isHTMLCollection(sourceObj: any): sourceObj is HTMLCollection {\n  return !!sourceObj && sourceObj.toString() === '[object HTMLCollection]';\n}\n\nfunction isEventTarget(sourceObj: any): sourceObj is EventTarget {\n  return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n\nexport type EventTargetLike = EventTarget | NodeStyleEventEmmitter | JQueryStyleEventEmitter | NodeList | HTMLCollection;\n\nexport type EventListenerOptions = {\n  capture?: boolean;\n  passive?: boolean;\n  once?: boolean;\n} | boolean;\n\nexport type SelectorMethodSignature<T> = (...args: Array<any>) => T;\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class FromEventObservable<T, R> extends Observable<T> {\n\n  /* tslint:disable:max-line-length */\n  static create<T>(target: EventTargetLike, eventName: string): Observable<T>;\n  static create<T>(target: EventTargetLike, eventName: string, selector: SelectorMethodSignature<T>): Observable<T>;\n  static create<T>(target: EventTargetLike, eventName: string, options: EventListenerOptions): Observable<T>;\n  static create<T>(target: EventTargetLike, eventName: string, options: EventListenerOptions, selector: SelectorMethodSignature<T>): Observable<T>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Creates an Observable that emits events of a specific type coming from the\n   * given event target.\n   *\n   * <span class=\"informal\">Creates an Observable from DOM events, or Node\n   * EventEmitter events or others.</span>\n   *\n   * <img src=\"./img/fromEvent.png\" width=\"100%\">\n   *\n   * Creates an Observable by attaching an event listener to an \"event target\",\n   * which may be an object with `addEventListener` and `removeEventListener`,\n   * a Node.js EventEmitter, a jQuery style EventEmitter, a NodeList from the\n   * DOM, or an HTMLCollection from the DOM. The event handler is attached when\n   * the output Observable is subscribed, and removed when the Subscription is\n   * unsubscribed.\n   *\n   * @example <caption>Emits clicks happening on the DOM document</caption>\n   * var clicks = Rx.Observable.fromEvent(document, 'click');\n   * clicks.subscribe(x => console.log(x));\n   *\n   * @see {@link from}\n   * @see {@link fromEventPattern}\n   *\n   * @param {EventTargetLike} target The DOMElement, event target, Node.js\n   * EventEmitter, NodeList or HTMLCollection to attach the event handler to.\n   * @param {string} eventName The event name of interest, being emitted by the\n   * `target`.\n   * @parm {EventListenerOptions} [options] Options to pass through to addEventListener\n   * @param {SelectorMethodSignature<T>} [selector] An optional function to\n   * post-process results. It takes the arguments from the event handler and\n   * should return a single value.\n   * @return {Observable<T>}\n   * @static true\n   * @name fromEvent\n   * @owner Observable\n   */\n  static create<T>(target: EventTargetLike,\n                   eventName: string,\n                   options?: EventListenerOptions,\n                   selector?: SelectorMethodSignature<T>): Observable<T> {\n    if (isFunction(options)) {\n      selector = <any>options;\n      options = undefined;\n    }\n    return new FromEventObservable(target, eventName, selector, options);\n  }\n\n  constructor(private sourceObj: EventTargetLike,\n              private eventName: string,\n              private selector?: SelectorMethodSignature<T>,\n              private options?: EventListenerOptions) {\n    super();\n  }\n\n  private static setupSubscription<T>(sourceObj: EventTargetLike,\n                                      eventName: string,\n                                      handler: Function,\n                                      subscriber: Subscriber<T>,\n                                      options?: EventListenerOptions) {\n    let unsubscribe: () => void;\n    if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {\n      for (let i = 0, len = sourceObj.length; i < len; i++) {\n        FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n      }\n    } else if (isEventTarget(sourceObj)) {\n      const source = sourceObj;\n      sourceObj.addEventListener(eventName, <EventListener>handler, <boolean>options);\n      unsubscribe = () => source.removeEventListener(eventName, <EventListener>handler);\n    } else if (isJQueryStyleEventEmitter(sourceObj)) {\n      const source = sourceObj;\n      sourceObj.on(eventName, handler);\n      unsubscribe = () => source.off(eventName, handler);\n    } else if (isNodeStyleEventEmmitter(sourceObj)) {\n      const source = sourceObj;\n      sourceObj.addListener(eventName, handler);\n      unsubscribe = () => source.removeListener(eventName, handler);\n    }\n\n    subscriber.add(new Subscription(unsubscribe));\n  }\n\n  protected _subscribe(subscriber: Subscriber<T>) {\n    const sourceObj = this.sourceObj;\n    const eventName = this.eventName;\n    const options = this.options;\n    const selector = this.selector;\n    let handler = selector ? (...args: any[]) => {\n      let result = tryCatch(selector)(...args);\n      if (result === errorObject) {\n        subscriber.error(errorObject.e);\n      } else {\n        subscriber.next(result);\n      }\n    } : (e: any) => subscriber.next(e);\n\n    FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/rxjs/src/observable/FromEventObservable.ts","import {  FromEventObservable  } from './FromEventObservable';\n\nexport const fromEvent = FromEventObservable.create;\n\n\n// WEBPACK FOOTER //\n// ./~/rxjs/src/observable/fromEvent.ts","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { PartialObserver } from '../Observer';\nimport { TeardownLogic } from '../Subscription';\n\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @method do\n * @name do\n * @owner Observable\n */\nexport function _do<T>(nextOrObserver?: PartialObserver<T> | ((x: T) => void),\n                       error?: (e: any) => void,\n                       complete?: () => void): Observable<T> {\n  return this.lift(new DoOperator(nextOrObserver, error, complete));\n}\n\nexport interface DoSignature<T> {\n  (next: (x: T) => void, error?: (e: any) => void, complete?: () => void): Observable<T>;\n  (observer: PartialObserver<T>): Observable<T>;\n}\n\nclass DoOperator<T> implements Operator<T, T> {\n  constructor(private nextOrObserver?: PartialObserver<T> | ((x: T) => void),\n              private error?: (e: any) => void,\n              private complete?: () => void) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source._subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DoSubscriber<T> extends Subscriber<T> {\n\n  private safeSubscriber: Subscriber<T>;\n\n  constructor(destination: Subscriber<T>,\n              nextOrObserver?: PartialObserver<T> | ((x: T) => void),\n              error?: (e: any) => void,\n              complete?: () => void) {\n    super(destination);\n\n    const safeSubscriber = new Subscriber<T>(nextOrObserver, error, complete);\n    safeSubscriber.syncErrorThrowable = true;\n    this.add(safeSubscriber);\n    this.safeSubscriber = safeSubscriber;\n  }\n\n  protected _next(value: T): void {\n    const { safeSubscriber } = this;\n    safeSubscriber.next(value);\n    if (safeSubscriber.syncErrorThrown) {\n      this.destination.error(safeSubscriber.syncErrorValue);\n    } else {\n      this.destination.next(value);\n    }\n  }\n\n  protected _error(err: any): void {\n    const { safeSubscriber } = this;\n    safeSubscriber.error(err);\n    if (safeSubscriber.syncErrorThrown) {\n      this.destination.error(safeSubscriber.syncErrorValue);\n    } else {\n      this.destination.error(err);\n    }\n  }\n\n  protected _complete(): void {\n    const { safeSubscriber } = this;\n    safeSubscriber.complete();\n    if (safeSubscriber.syncErrorThrown) {\n      this.destination.error(safeSubscriber.syncErrorValue);\n    } else {\n      this.destination.complete();\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/rxjs/src/operator/do.ts","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { TeardownLogic } from '../Subscription';\n\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctKey}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nexport function filter<T>(predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): Observable<T> {\n  return this.lift(new FilterOperator(predicate, thisArg));\n}\n\nexport interface FilterSignature<T> {\n  (predicate: (value: T, index: number) => boolean, thisArg?: any): Observable<T>;\n}\n\nclass FilterOperator<T> implements Operator<T, T> {\n  constructor(private predicate: (value: T, index: number) => boolean,\n              private thisArg?: any) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source._subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass FilterSubscriber<T> extends Subscriber<T> {\n\n  count: number = 0;\n\n  constructor(destination: Subscriber<T>,\n              private predicate: (value: T, index: number) => boolean,\n              private thisArg: any) {\n    super(destination);\n    this.predicate = predicate;\n  }\n\n  // the try catch block below is left specifically for\n  // optimization and perf reasons. a tryCatcher is not necessary here.\n  protected _next(value: T) {\n    let result: any;\n    try {\n      result = this.predicate.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    if (result) {\n      this.destination.next(value);\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/rxjs/src/operator/filter.ts","import { root } from '../util/root';\n\nexport function getSymbolObservable(context: any) {\n  let $$observable: any;\n  let Symbol = context.Symbol;\n\n  if (typeof Symbol === 'function') {\n    if (Symbol.observable) {\n      $$observable = Symbol.observable;\n    } else {\n        $$observable = Symbol('observable');\n        Symbol.observable = $$observable;\n    }\n  } else {\n    $$observable = '@@observable';\n  }\n\n  return $$observable;\n}\n\nexport const $$observable = getSymbolObservable(root);\n\n\n// WEBPACK FOOTER //\n// ./~/rxjs/src/symbol/observable.ts","/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport class UnsubscriptionError extends Error {\n  constructor(public errors: any[]) {\n    super();\n    const err: any = Error.call(this, errors ?\n      `${errors.length} errors occurred during unsubscription:\n  ${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}` : '');\n    (<any> this).name = err.name = 'UnsubscriptionError';\n    (<any> this).stack = err.stack;\n    (<any> this).message = err.message;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/rxjs/src/util/UnsubscriptionError.ts","export const isArray = Array.isArray || (<T>(x: any): x is T[] => x && typeof x.length === 'number');\n\n\n\n// WEBPACK FOOTER //\n// ./~/rxjs/src/util/isArray.ts","export function isObject(x: any): x is Object {\n  return x != null && typeof x === 'object';\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/rxjs/src/util/isObject.ts","import { PartialObserver } from '../Observer';\nimport { Subscriber } from '../Subscriber';\nimport { $$rxSubscriber } from '../symbol/rxSubscriber';\n\nexport function toSubscriber<T>(\n  nextOrObserver?: PartialObserver<T> | ((value: T) => void),\n  error?: (error: any) => void,\n  complete?: () => void): Subscriber<T> {\n\n  if (nextOrObserver) {\n    if (nextOrObserver instanceof Subscriber) {\n      return (<Subscriber<T>> nextOrObserver);\n    }\n\n    if (nextOrObserver[$$rxSubscriber]) {\n      return nextOrObserver[$$rxSubscriber]();\n    }\n  }\n\n  if (!nextOrObserver && !error && !complete) {\n    return new Subscriber();\n  }\n\n  return new Subscriber(nextOrObserver, error, complete);\n}\n\n\n// WEBPACK FOOTER //\n// ./~/rxjs/src/util/toSubscriber.ts","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() { return this; })();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 34\n// module chunks = 0","import { NgModule } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\r\n\r\nimport { TagInputAutocompleteComponent } from './tag-input-autocomplete/tag-input-autocomplete.component';\r\nimport { TagInputComponent } from './tag-input/tag-input.component';\r\nimport { TagInputItemComponent } from './tag-input-item/tag-input-item.component';\r\n\r\n@NgModule({\r\n  imports: [\r\n    CommonModule,\r\n    FormsModule,\r\n    ReactiveFormsModule\r\n  ],\r\n  declarations: [\r\n    TagInputAutocompleteComponent,\r\n    TagInputComponent,\r\n    TagInputItemComponent\r\n  ],\r\n  exports: [\r\n    TagInputComponent\r\n  ]\r\n})\r\nexport class RlTagInputModule {}\r\n\n\n\n// WEBPACK FOOTER //\n// lib/tag-input.module.ts"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9DA;;;;;;ACAA;;;;;;;;ACIA;AACA;AAGA;AAWA;;;;;AAKA;AACA;AAOA;;;;;;AAMA;AACA;AAZA;AAaA;AACA;AACA;AACA;AAgBA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAUA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;AAMA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAMA;;;;AAIA;AACA;AACA;AACA;AA3HA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AAgHA;AAAA;AAhJA;;;;;;;ACzBA;;;;;;;;;;;;;ACAA;AAEA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AAAA;AA8BA;;;;;;;AAOA;AACA;AAGA;AAlBA;AACA;AACA;AAEA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjEA;AAEA;;;;;;;;;;AAUA;AACA;AAGA;AACA;AACA;AACA;AAgDA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAlIA;AAoIA;;;;AAIA;AACA;AAAA;AAIA;AAIA;AAJA;AAMA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;ACrQA;AACA;;;;;;;;;ACDA;AACA;AACA;AAFA;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAaA;AAEA;AACA;AACA;AACA;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AAaA;;;;;;;;;;;AAWA;AACA;AAYA;;;AAGA;AACA;AAVA;;;AAGA;AACA;AAOA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;AAiBA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AApJA;AACA;AACA;AACA;AAkJA;AAAA;AAtJA;;;;;;;;;AC9BA;AAEA;AAEA;AACA;;;;;;;;;ACLA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAHA;AAGA;;;;;;;;;;;;;;;;;;AChBA;AACA;AAEA;AACA;AACA;AAEA;AAOA;AAWA;AAAA;AATA;AACA;AACA;AACA;AAMA;AAJA;AAAA;AACA;AACA;;;AAAA;AAIA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AApIA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AATA;AAAA;AACA;AACA;AACA;AACA;;AAAA;AAuIA;AAAA;AAtIA;;;;;;;;;;;;;;;;;;ACdA;AAOA;AAOA;AAHA;AAGA;AAEA;AACA;AACA;AAVA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AAVA;AAAA;AACA;AACA;AACA;AACA;;AAAA;AAaA;AAAA;AAZA;;;;;;;;;;;;;;;;;;ACPA;AACA;AAGA;AAKA;AACA;AACA;AAcA;AA+BA;AAAA;AA7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAmKA;AAEA;AA1JA;AAPA;AAAA;AACA;AACA;;;AAAA;AACA;AAAA;AACA;AACA;;;AAAA;AAIA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAOA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAxMA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AACA;AAAA;;AAAA;AAxBA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAAA;AA2MA;AAAA;AA1MA;;;;;;;ACzBA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;;;AC8BA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACnCA;AACA;AAEA;;;;;;;;;ACFA;AACA;AAEA;AACA;;;;;;;;;ACJA;AACA;AAEA;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AAMA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAYA;;;;AAIA;AACA;AAAA;AAwDA;AAIA;AAJA;AACA;AACA;AACA;AAEA;AAtDA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AASA;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AA1GA;;;;;;;;;AClDA;AAEA;;;;;;;;;;;;;;ACDA;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0CA;AACA;AAGA;AACA;AAJA;AAWA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;;;;AAIA;AACA;AAAA;AAIA;AAIA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;ACvHA;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCA;AACA;AAEA;AACA;AAHA;AASA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;;;;AAIA;AACA;AAAA;AAIA;AAGA;AAFA;AACA;AAJA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;AC9FA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAhBA;AAkBA;;;;;;;;;;;;;;ACpBA;;;AAGA;AACA;AAAA;AACA;AACA;AADA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAVA;;;;;;;;;ACJA;;;;;;;;;ACAA;AACA;AACA;AAFA;;;;;;;;;ACCA;AACA;AAEA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AApBA;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClBA;AACA;AACA;AAEA;AACA;AACA;AAiBA;AAAA;AAAA;AAfA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;AAAA;AAAA;;;;;;","sourceRoot":""}